# 2 "asmcomp/wasm64/emit.mlp"
[@@@warning "-27"]
open Cmm
open Arch
open Proc
open Reg
open Mach
open Linear
open Emitaux
open Emitenv

module String = Misc.Stdlib.String

(* let wasm_module = ref (Module.create ()) *)

(* Section switching *)

let data_space =
  ".section .data,\"\",@"

let _code_space =
  ".section .text,\"\",@"

let rodata_space =
  ".section .rodata,\"S\",@"

let reg_map = Hashtbl.create 0

let initial_stack_offset f =
  size_addr * f.fun_num_stack_slots.(0) +
  size_int * f.fun_num_stack_slots.(1) +
  size_float * f.fun_num_stack_slots.(1)

let frame_size env =
  if env.f.fun_frame_required then begin
    let sz =
      env.stack_offset + initial_stack_offset env.f + 8
    in Misc.align sz 16
  end else
    env.stack_offset + 8

let slot_offset env loc cl =
  let num_slots = env.f.fun_num_stack_slots in
  match loc with
    Incoming n ->
      assert (n >= 0);
      frame_size env + n
  | Local n ->
      env.stack_offset +
      (match cl with
      | 0 -> n * size_addr
      | 1 -> num_slots.(0) * size_addr + n * size_int
      | 2 -> num_slots.(0) * size_addr + num_slots.(1) * size_int + n * size_float
      | _ -> assert false)
  | Outgoing n ->
      assert (n >= 0);
      n
  | Domainstate _ -> assert false  (* not a stack slot *)


let get_type = function
  | Val -> "i64"
  | Addr -> "i64"
  | Int -> "i64"
  | Float -> "f64"

let emit_conversion t1 t2 =
  match t1, t2 with
  | (Val | Int), Addr ->
()
  | Addr, (Val | Int) ->
()
  | Addr, Addr | Val, Val | Int, Int | Float, Float | Val, Int | Int, Val -> ()
  | _ -> assert false

let emit_get_reg env reg =
  match reg with
  | { loc = Reg _ } ->
      (match Hashtbl.find_opt reg_map reg.loc with
      | Some reg ->
          `	local.get    {emit_int reg}\n`;
      | None -> Printmach.reg Format.std_formatter reg; failwith "not found - get")
  | { loc = Stack s } ->
      let ofs = slot_offset env s (register_class reg) in
      `	global.get    __stack_pointer\n`;
      `	i64.const    {emit_int ofs}\n`;
      `	i64.add\n`;
      `	{emit_string (get_type reg.typ)}.load    0\n`
  | { loc = Unknown } -> assert false

let emit_set_reg env reg emit_val =
  match reg with
  | { loc = Reg _ } ->
      (match Hashtbl.find_opt reg_map reg.loc with
      | Some reg ->
          emit_val ();
          `	local.set    {emit_int reg}\n`;
      | None -> Printmach.reg Format.std_formatter reg; failwith "not found - set")
  | { loc = Stack s } ->
      let ofs = slot_offset env s (register_class reg) in
      `	global.get    __stack_pointer\n`;
      `	i64.const    {emit_int ofs}\n`;
      `	i64.add\n`;
      emit_val ();
      `	{emit_string (get_type reg.typ)}.store    0\n`
  | { loc = Unknown } -> assert false

let emit_load env src dst =
  emit_get_reg env src;
  emit_conversion src.typ Addr;
  (fun () -> `	i64.load     0\n`) |>
  emit_set_reg env dst

let emit_store env ?(ofs = 0) src dst=
  emit_get_reg env dst;
  `	i64.const    {emit_int ofs}\n`;
  `	i64.add\n`;
  emit_conversion dst.typ Addr;
  emit_get_reg env src;
  `	{emit_string (get_type src.typ)}.store    0\n`

let emit_symbol s =
  emit_symbol '$' s

let symbols_defined = ref String.Set.empty
let symbols_used = ref String.Set.empty

let add_def_symbol s = symbols_defined := String.Set.add s !symbols_defined
let add_used_symbol s = symbols_used := String.Set.add s !symbols_used

let emit_jump op s =
  `{emit_string op}	{emit_symbol s}`

let emit_call = emit_jump "call"

let get_domain_field f =
  `	global.get __caml_state\n`;
  `	i64.load {emit_int (Domainstate.idx_of_field f * size_addr)}\n`

let set_domain_field f emit_val =
  `	global.get __caml_state\n`;
  emit_val ();
  `	i64.store {emit_int (Domainstate.idx_of_field f * size_addr)}\n`

let emit_label lbl =
  emit_string ".L"; emit_int lbl

let name_for_int_operation = function
  | Iadd -> "add"
  | Isub -> "sub"
  | Imul -> "mul"
  | Imulh -> assert false
  | Imod -> "rem_s"
  | Idiv -> "div_s"
  | Iand -> "and"
  | Ior  -> "or"
  | Ixor -> "xor"
  | Ilsl -> "shl"
  | Ilsr -> "shr_u"
  | Iasr -> "shr_s"
  | Icomp _ -> assert false
  | Icheckbound -> ""

let fake_address_labels = ref []

let record_frame_label env live dbg =
  let lbl = new_label () in
  let live_offset = ref [] in
  Reg.Set.iter
    (function
      | {typ = Val; loc = Reg r} ->
          assert false
          (* live_offset := ((r lsl 1) + 1) :: !live_offset *)
      | {typ = Val; loc = Stack s} as reg ->
          live_offset := slot_offset env s (register_class reg) :: !live_offset
      | {typ = Addr} as r ->
          Misc.fatal_error ("bad GC root " ^ Reg.name r)
      | _ -> ())
    live;
  record_frame_descr ~label:lbl ~frame_size:(frame_size env)
    ~live_offset:!live_offset dbg;
  lbl

let record_frame env live dbg =
  let lbl = record_frame_label env live dbg in
  fake_address_labels := lbl :: !fake_address_labels;
  `{emit_label lbl}_fake:\n`;
  lbl

(* type cfg = *)
(*   { label: string; *)
(*     mutable body : 'a. 'a; *)
(*     mutable fallthrough : cfg option; *)
(*     mutable } *)

type wasm_instruction =
  { desc: wasm_control_flow;
    arg: Reg.t array;
    res: Reg.t array;
    dbg: Debuginfo.t;
    live: Reg.Set.t }

and wasm_control_flow =
  | Wprologue
  | Wend
  | Wop of Mach.operation
  | Wreturn
  | Wblock of label
  | Wendblock
  | Wloop of label
  | Wendloop
  | Wbranch of label
  | Wtailrec of label
  | Wcondbranch of Mach.test * label
  | Wcondbranch3 of label option * label option * label option
  | Wswitch of label array
  | Wraise of Lambda.raise_kind
  | Wadjust_trap_depth of int
  | Wpoptrap
  | Wunreachable
  | Wtry
  | Wcatch of label

let mk_instr ?(arg = [||]) desc =
  { desc = desc;
    arg;
    res = [||];
    dbg = Debuginfo.none;
    live = Reg.Set.empty }


let loop_idx_reg = Reg.at_location Int (Reg 0xBADC0DE)

let blocks_map = Hashtbl.create 0

let reloop instructions : wasm_instruction list =
  let rec group current current_lbl acc = function
    | Linear.{ desc = Lend; _ } -> ((current_lbl, current) :: acc)
    | { desc = Llabel lbl; next; _ } -> group [] lbl ((current_lbl, current) :: acc) next
    | { next; _ } as inst -> group (inst :: current) current_lbl acc next
  in
  let groups = group [] (-1) [] instructions in
  let convert = function
  | Lprologue -> Wprologue
  | Lend -> Wend
  | Lop op -> Wop op
  | Lreloadretaddr -> Wend (* assert false *)
  | Lreturn -> Wreturn
  | Llabel _ -> assert false
  | Lbranch lbl -> Wbranch lbl
  | Lcondbranch(tst, lbl) -> Wcondbranch(tst, lbl)
  | Lcondbranch3(lbl0, lbl1, lbl2) -> Wcondbranch3(lbl0, lbl1, lbl2)
  | Lswitch jumptbl -> Wswitch jumptbl
  | Lraise k -> Wraise k
  | Lentertrap
  | Ladjust_trap_depth _
  | Lpushtrap _
  | Lpoptrap -> assert false
  in
  let a = List.rev_map (fun (lbl, instrs) ->
    (lbl, List.rev_map (fun { desc; next; arg; res; dbg; live } ->
      { desc = convert desc; arg; res; dbg; live; }
    ) instrs)
  ) groups
  in
  let rec add_br = function
    | (lbl, instrs) :: (((next_lbl, _) :: _) as tl) -> (lbl, instrs @ [mk_instr (Wbranch next_lbl)]) :: add_br tl
    | tl -> tl
  in
  let a = add_br a in
  let switch_block = new_label () in
  let labels = List.map (fun (lbl, _) -> lbl) a in
  Hashtbl.clear blocks_map;
  List.iteri (fun i lbl -> Hashtbl.add blocks_map lbl i) labels;
  let labels = List.rev labels in
  let blocks = List.map (fun lbl -> mk_instr (Wblock lbl)) labels in
  let labels = List.rev labels in
  let labels = Array.of_list labels in
  let a = List.map (fun (lbl, instrs) -> instrs @ [mk_instr Wendblock]) a in
  let a = List.flatten a in
  mk_instr (Wloop (-2)) :: blocks @ mk_instr (Wblock switch_block)
    :: (mk_instr ~arg:([|loop_idx_reg|]) (Wswitch labels)) :: (mk_instr Wendblock) :: a @ [mk_instr Wendloop; mk_instr Wunreachable]

[@@@warning "-69"]
module LblSet = Stdlib.Set.Make(Int)
module Cfg : sig
  module Node :
    sig
      type t
      val get_label : t -> label
      val get_body : t -> wasm_instruction list
      val set_body : t -> wasm_instruction list -> unit
    end
  type t
  type control_flow = [\`Branch | \`Condbranch of test | \`Tailrec | \`Fake]
  val cfg_of_instructions : Linear.fundecl -> t
  val dag_of_cfg : t -> t * (label * label) list
  val get_adjacent_nodes : t -> label -> label list
  val get_adjacent_try_catch_edges : t -> label -> (label * label) list
  val iter_nodes : t -> (label -> unit) -> unit
  val get_node : t -> label -> Node.t
  val get_edge_instr : t -> label -> label -> instruction option * control_flow
end = struct
  module Node : sig
    type t
    val get_label : t -> label
    val make : label -> wasm_instruction list -> t
    val get_body : t -> wasm_instruction list
    val set_body : t -> wasm_instruction list -> unit
  end = struct
    type t = {
      label: label;
      mutable body: wasm_instruction list
    }
    let get_label t = t.label
    let make label body = { label; body; }
    let get_body t = t.body
    let set_body t body = t.body <- body
  end

  type control_flow = [\`Branch | \`Condbranch of test | \`Tailrec | \`Fake ]

  type t = {
    entry: label;
    nodes: (label, Node.t) Hashtbl.t;
    edges: (label * label * instruction option * control_flow) list;
    try_edges: (label * label * label) list;
    adjacency_list: (label, label list) Hashtbl.t
  }

  let create_adjacency_list nodes edges =
    let adjacency_list = Hashtbl.create (Hashtbl.length nodes) in
    Hashtbl.iter (fun label _ -> Hashtbl.add adjacency_list label []) nodes;
    List.iter (fun (src, dst, _, _) ->
      Hashtbl.replace adjacency_list src (dst :: Hashtbl.find adjacency_list src)) edges;
    adjacency_list

  let get_adjacent_nodes t lbl =
    Hashtbl.find t.adjacency_list lbl

  let get_adjacent_try_catch_edges t lbl =
    List.filter_map (fun (src, dst, lbl_handler) -> if src = lbl then Some(dst,lbl_handler) else None) t.try_edges

  let iter_nodes t f =
    Hashtbl.iter (fun label _ -> f label) t.nodes

  let get_node t l =
    Hashtbl.find t.nodes l

  let get_edge_instr t src dst =
    let (_, _,i, control_flow) = List.find (fun (a, b, _, _) -> a = src && b = dst) t.edges in
    i, control_flow

  let get_back_edges cfg =
    let dfs cfg f init =
      let visited = Hashtbl.create 10 in

      let rec visit src f acc =
        if not (Hashtbl.mem visited src) then begin
          Hashtbl.add visited src ();
          List.iter (fun dst ->
              visit dst f (f src dst acc)
            ) (Hashtbl.find cfg.adjacency_list src);
        end
      in
      visit cfg.entry f init
    in
    let back_edges = ref [] in
    let f src dst visited =
      match LblSet.mem dst visited with
      | true ->
          back_edges := (src, dst) :: !back_edges;
          visited
      | false ->
          begin if src = dst then
            back_edges := (src, dst) :: !back_edges
          end;
          LblSet.add src visited
    in
    dfs cfg f LblSet.empty;
    !back_edges
  let cfg_of_instructions fundecl =
    let convert { desc; next; arg; res; dbg; live } =
      let convert = function
      | Lprologue -> Wprologue
      | Lend -> Wend
      | Lop op -> Wop op
      | Lreloadretaddr -> assert false (* assert false *)
      | Lreturn -> Wreturn
      | Llabel _ -> assert false
      | Lbranch _ -> assert false
      | Lcondbranch(_, _) -> assert false
      | Lcondbranch3(_, _, _) -> assert false
      | Lswitch jumptbl -> assert false
      | Lraise k -> Wraise k
      | Lentertrap -> assert false
      | Ladjust_trap_depth { delta_traps } -> Wadjust_trap_depth delta_traps
      | Lpushtrap _
      | Lpoptrap -> assert false
      in
      { desc = convert desc; arg; res; dbg; live; }
    in
    let entry = new_label () in
    let nodes = Hashtbl.create 10 in
    let add_cfg lbl instructions =
      (* Hashtbl.add nodes lbl Node.{ label = lbl; body = List.rev instructions } *)
      Hashtbl.add nodes lbl (Node.make lbl (List.rev instructions))
    in
    let edges = ref [] in
    let try_edges = ref [] in
    let trap_start = ref [] in
    (* let trap_end = ref [] in *)
    let rec instructions_to_cfg current current_lbl = function
    | Linear.{ desc = Lend } as i -> add_cfg current_lbl (convert i :: current)
    | { desc = Lbranch lbl; next } as i ->
        let new_lbl = new_label () in
        add_cfg current_lbl current;
        edges := (current_lbl, new_lbl, None, \`Branch) :: (current_lbl, lbl, Some i, \`Branch) :: !edges;
        instructions_to_cfg [] new_lbl next
    | { desc = Lop(Itailcall_imm { func; }); next } as i when func = fundecl.fun_name  ->
        let new_lbl = new_label () in
        add_cfg current_lbl current;
        edges := (current_lbl, new_lbl, None, \`Branch) :: (current_lbl, fundecl.fun_tailrec_entry_point_label, Some i, \`Tailrec) :: !edges;
        instructions_to_cfg [] new_lbl next
    | { desc = Lcondbranch (tst, lbl); next } as i ->
        let new_lbl = new_label () in
        add_cfg current_lbl current;
        edges := (current_lbl, new_lbl, None, \`Branch) :: (current_lbl, lbl, Some i, \`Condbranch tst) :: !edges;
        instructions_to_cfg [] new_lbl next
    | { desc = Lcondbranch3 (lbl0, lbl1, lbl2); next } as i ->
        add_cfg current_lbl current;
        let previous_lbl = ref current_lbl in
        begin match lbl0 with
        | None -> ()
        | Some lbl ->
          let new_lbl = new_label () in
          add_cfg new_lbl [];
          edges := (!previous_lbl, new_lbl, None, \`Branch) :: (!previous_lbl, lbl, Some i, \`Condbranch (Iinttest_imm (Iunsigned Clt, 1))) :: !edges;
          previous_lbl := new_lbl
        end;
        begin match lbl1 with
        | None -> ()
        | Some lbl ->
          let new_lbl = new_label () in
          add_cfg new_lbl [];
          edges := (!previous_lbl, new_lbl, None, \`Branch) :: (!previous_lbl, lbl, Some i, \`Condbranch (Iinttest_imm (Iunsigned Ceq, 1))) :: !edges;
          previous_lbl := new_lbl
        end;
        begin match lbl2 with
        | None -> ()
        | Some lbl ->
          let new_lbl = new_label () in
          add_cfg new_lbl [];
          edges := (!previous_lbl, new_lbl, None, \`Branch) :: (!previous_lbl, lbl, Some i, \`Condbranch (Iinttest_imm (Iunsigned Cgt, 1))) :: !edges;
          previous_lbl := new_lbl
        end;
        let new_lbl = new_label () in
        edges := (!previous_lbl, new_lbl, None, \`Branch) :: !edges;
        instructions_to_cfg [] new_lbl next
    | { desc = Lswitch jumptbl; next } as i ->
        let previous_lbl = ref current_lbl in
        add_cfg current_lbl current;
        for j = 0 to Array.length jumptbl - 2 do
          let new_lbl = new_label () in
          add_cfg new_lbl [];
          edges := (!previous_lbl, new_lbl, None, \`Branch) :: (!previous_lbl, jumptbl.(j), Some i, \`Condbranch (Iinttest_imm (Iunsigned Ceq, j))) :: !edges;
          previous_lbl := new_lbl
        done;
        let new_lbl = new_label () in
        edges := (!previous_lbl, new_lbl, None, \`Branch) :: (!previous_lbl, (jumptbl.(Array.length jumptbl - 1)), Some i, \`Branch) :: !edges;
        instructions_to_cfg [] new_lbl next;
    | { desc = Lpushtrap { lbl_handler }; next } ->
        let lbl = new_label () in
        add_cfg current_lbl current;
        edges := (current_lbl, lbl, None, \`Branch) :: !edges;
        trap_start := (lbl, lbl_handler) :: !trap_start;
        instructions_to_cfg [] lbl next
    | { desc = Lpoptrap; next } ->
        instructions_to_cfg (mk_instr (Wpoptrap) :: current) current_lbl next
    (* | { desc = Ladjust_trap_depth { delta_traps }; next } -> *)
    (*     assert (delta_traps = 1 || delta_traps = -1); *)
    (*     instructions_to_cfg current current_lbl next *)
    | { desc = Llabel lbl; next = { desc = Lentertrap; next } } ->
        (* trap_end := current_lbl :: !trap_end; *)
        begin match !trap_start with
        | (a, b) :: tl ->
            trap_start := tl;
            try_edges := (a, current_lbl, b) :: !try_edges
        | _ -> assert false
        end;
        add_cfg current_lbl current;
        edges := (current_lbl, lbl, None, \`Branch) :: !edges;
        instructions_to_cfg [] lbl next
    | { desc = Lreloadretaddr; next } ->
        instructions_to_cfg current current_lbl next
    | { desc = Llabel lbl; next } ->
        add_cfg current_lbl current;
        edges := (current_lbl, lbl, None, \`Branch) :: !edges;
        instructions_to_cfg [] lbl next
    | Linear.{ next } as inst ->
        instructions_to_cfg (convert inst :: current) current_lbl next
    in
    instructions_to_cfg [] entry fundecl.fun_body;
    assert (List.length !trap_start = 0);
    (* assert (0 = List.compare_lengths !trap_start !trap_end); *)
    (* let trap_start = !trap_start in *)
    (* let trap_end = List.rev (!trap_end) in *)
    (* let try_edges = List.map2 (fun (a, b) c -> (a, c, b)) trap_start trap_end in *)
    let try_edges = !try_edges in
    let edges = (List.map (fun (_, dst, lbl_handler) -> (dst, lbl_handler, None, \`Fake)) try_edges) @ !edges in
    let cfg = {
      entry;
      nodes;
      edges;
      try_edges;
      adjacency_list = create_adjacency_list nodes edges;
    }
    in
    cfg

  let dag_of_cfg cfg =
    let back_edges = get_back_edges cfg in
    (* Printf.printf "num back edges %d\n" (List.length back_edges); *)
    let back_edges_tbl = Hashtbl.create 10 in
    List.iter (fun edge -> Hashtbl.add back_edges_tbl edge ()) back_edges;
    let filtered_edges = List.filter (fun (src, dst, _, _) -> not (Hashtbl.mem back_edges_tbl (src, dst))) cfg.edges in
    let dag =
      { cfg with edges = filtered_edges; adjacency_list = create_adjacency_list cfg.nodes filtered_edges}
    in
    dag, back_edges
end

module Structured = struct
  type structured = { block: block; mutable next: structured }
  and block =
    | Node of Cfg.Node.t
    | Block of label * structured
    | Loop of label * structured
    | TryCatch of label * structured
    | End
    | Start

  let rec print_block ?(print = false) = function
  | { block = End } ->
      Printf.printf "end\n"
  | { block = Start; next } ->
      Printf.printf "start\n"; print_block ~print next
  | { block = Node node; next } ->
      Printf.printf "%d\n" (Cfg.Node.get_label node);
      if print then
        (List.iter (function {desc = Wop(op)} as i->
          Printmach.operation op i.arg Format.std_formatter i.res;
          if not (Debuginfo.is_none i.dbg) && !Clflags.locations then
            Format.fprintf Format.std_formatter " %s" (Debuginfo.to_string i.dbg);
          Printf.printf "\n";
        | _ -> ()) (Cfg.Node.get_body node));
      print_block ~print next
  | { block = Block (lbl, blocks); next } ->
      Printf.printf "block %d\n" lbl; print_block ~print blocks;
      Printf.printf "endblock\n";
      print_block ~print next
  | { block = Loop (lbl, blocks); next } ->
      Printf.printf "loop %d\n" lbl;
      print_block ~print blocks;
      Printf.printf "endloop\n";
      print_block ~print next
  | { block = TryCatch (lbl, blocks); next } ->
      Printf.printf "try\n";
      print_block ~print blocks;
      Printf.printf "catch %d\n" lbl;
      print_block ~print next;
end

let rec end_block = Structured.{ block = End; next = end_block }

let cfg_reloop fundecl =
  let open Structured in
  let cfg = Cfg.cfg_of_instructions fundecl in
  let dag, back_edges = Cfg.dag_of_cfg cfg in
  let order = ref [] in
  let visited = Hashtbl.create 10 in
  let rec visit node =
    if not (Hashtbl.mem visited node) then begin
      List.iter visit (Cfg.get_adjacent_nodes dag node);
      Hashtbl.add visited node ();
      order := node :: !order
    end
  in
  (* Printf.printf "entry: %d\n" cfg.entry; *)
  (* Printf.printf "edges list\n"; *)
  (* List.iter (fun (a, b, _, e) -> Printf.printf "%d - %d (%s)\n" a b (match e with | \`Branch -> "br" | \`Condbranch _ -> "condbr" | _ -> assert false)) cfg.edges; *)
  (* Printf.printf "dag edges list\n"; *)
  (* List.iter (fun (a, b, _, e) -> Printf.printf "%d - %d (%s)\n" a b (match e with | \`Branch -> "br" | \`Condbranch _ -> "condbr" | _ -> assert false)) dag.edges; *)
  (* Printf.printf "order list\n"; *)
  Cfg.iter_nodes dag visit;
  (* List.iter (Printf.printf "%d ") !order; *)
  (* Printf.printf "\n"; *)
  let block = { block = Start; next = end_block } in
  List.fold_left (fun block lbl -> block.next <- { block = Node (Cfg.get_node cfg lbl); next = block.next}; block.next) block !order |> ignore;
  (* let merged = ref [] in *)
  ignore print_block;
  (* Printf.printf "start reloop\n"; *)
  (* print_block block ~print:true; *)
  (* Printf.printf "\n"; *)
  let rec contains lbl = function
  | { block = Node node } when Cfg.Node.get_label node = lbl -> true
  | { block = Node _; next } -> contains lbl next
  | { block = Start; next } -> contains lbl next
  | { block = End } -> false
  | { block = Block (_, blocks) | Loop (_, blocks) | TryCatch (_, blocks); next } -> contains lbl blocks || contains lbl next
  in
  let is_first lbl = function
  | { block = Node node } when Cfg.Node.get_label node = lbl -> true
  | { block = Node _ } -> false
  | { block = Start; next } -> contains lbl next
  | { block = End } -> false
  | { block = Block (_, blocks) | Loop (_, blocks) | TryCatch (_, blocks) } -> contains lbl blocks
  in
  let rec find_pred lbl block =
    match block.next with
    | { block = End } -> assert false
    | { block = Node node } when Cfg.Node.get_label node = lbl ->
        block
    | _ -> find_pred lbl block.next
  in
  let rec find_innermost_pred src_lbl dst_lbl block =
    match block.next with
    | { block = End } -> assert false
    | { block = Block (_, blocks) | Loop(_, blocks) | TryCatch (_, blocks) } when contains src_lbl blocks && contains dst_lbl blocks ->
        find_innermost_pred src_lbl dst_lbl blocks
    | { block = b; next } when contains src_lbl ({block = b; next = end_block} )->
         block
    | _ -> find_innermost_pred src_lbl dst_lbl block.next
  in
  let add_control_flow_body lbl control_flow i node =
    let desc =
    match control_flow with
    | \`Branch -> Wbranch lbl
    | \`Tailrec -> Wtailrec lbl
    | \`Condbranch tst -> Wcondbranch (tst, lbl)
   in
   let body = Cfg.Node.get_body node in
   let body = body @ [ match i with
   | Some Linear.{ arg; res; dbg; live; } ->
        { arg; res; dbg; live; desc; }
   | None -> mk_instr desc ] in
   Cfg.Node.set_body node body
  in
  let add_block src_lbl dst_lbl =
    let instr, control_flow = Cfg.get_edge_instr cfg src_lbl dst_lbl in
    let new_lbl = match control_flow with
      | \`Fake -> dst_lbl
      | _ -> new_label () in
    let parent_block = find_innermost_pred src_lbl dst_lbl block in
    let final_block = find_pred dst_lbl parent_block in
    parent_block.next <- { block = Block (new_lbl, { block = Start; next = parent_block.next }); next = final_block.next };
    final_block.next <- end_block;
    let node = Cfg.get_node cfg src_lbl in
    match control_flow with
    | \`Fake -> ()
    | (\`Branch | \`Condbranch _)  as control_flow ->
        add_control_flow_body new_lbl control_flow instr node
    | \`Tailrec -> assert false
  in
  let add_loop src_lbl dst_lbl =
    let new_lbl = new_label () in
    let parent_block = find_innermost_pred src_lbl dst_lbl block in
    assert (is_first src_lbl parent_block.next);
    let final_block = (find_pred dst_lbl parent_block).next in
    parent_block.next <- { block = Loop (new_lbl, { block = Start; next = parent_block.next }); next = final_block.next };
    final_block.next <- end_block;
    let instr, control_flow = Cfg.get_edge_instr cfg dst_lbl src_lbl in
    let node = Cfg.get_node cfg dst_lbl in
    match control_flow with
    | \`Fake -> assert false
    | (\`Branch | \`Condbranch _ | \`Tailrec)  as control_flow ->
        add_control_flow_body new_lbl control_flow instr node
  in
  let rec insert_blocks = function
  | [] -> ()
  | src_lbl :: tl ->
    let try_catch_edges = Cfg.get_adjacent_try_catch_edges cfg src_lbl in
    List.iter (fun (dst_lbl, lbl_handler) ->
      let parent_block = find_innermost_pred src_lbl dst_lbl block in
      assert (is_first src_lbl parent_block.next);
      let final_block = (find_pred dst_lbl parent_block).next in
      parent_block.next <- { block = TryCatch (lbl_handler, { block = Start; next = parent_block.next }); next = final_block.next };
      final_block.next <- end_block
    ) try_catch_edges;

    List.iter (fun dst_lbl ->
      add_loop src_lbl dst_lbl
    ) (List.filter_map (fun (src, dst) -> if dst = src_lbl then Some src else None) back_edges);
    let edges = Cfg.get_adjacent_nodes dag src_lbl in
    List.iter (fun dst_lbl ->
     let _, control_flow = Cfg.get_edge_instr cfg src_lbl dst_lbl in
      if (not (List.nth_opt tl 0 = Some dst_lbl) || control_flow = \`Fake) then begin
        add_block src_lbl dst_lbl
      end
      ) edges;
    insert_blocks tl
  in
  insert_blocks !order;
  (* print_block block; *)
  let rec render_block = function
  | { block = End } -> []
  | { block = Start; next } -> render_block next
  | { block = Node node; next } -> Cfg.Node.get_body node @ render_block next
  | { block = Block (lbl, blocks); next } ->
      mk_instr (Wblock lbl) :: render_block blocks @ [mk_instr (Wendblock)] @ render_block next
  | { block = Loop (lbl, blocks); next } ->
      mk_instr (Wloop lbl) :: render_block blocks @ [mk_instr (Wendloop)] @ render_block next
  | { block = TryCatch (lbl, blocks); next } ->
      (mk_instr Wtry) :: render_block blocks @ [mk_instr (Wcatch lbl)] @ render_block next
  in
  render_block block

let lbl_stack = ref []

let push_lbl lbl =
  lbl_stack := lbl :: !lbl_stack

let pop_lbl () =
  lbl_stack := List.tl !lbl_stack

let _get_loop_idx () =
  List.length !lbl_stack - 1

let get_idx lbl =
  let rec func x c = function
    | [] -> failwith (Printf.sprintf "lbl not found %d" lbl)
    | hd::tl when hd = x -> c
    | hd::tl -> func x (c+1) tl
  in
  let find x lst = func x 0 lst in
  let idx = find lbl !lbl_stack in
  idx


let name_for_comparison = function
  | Isigned Ceq -> "i64.eq" | Isigned Cne -> "i64.ne" | Isigned Cle -> "i64.le_s"
  | Isigned Cge -> "i64.ge_s" | Isigned Clt -> "i64.lt_s" | Isigned Cgt -> "i64.gt_s"
  | Iunsigned Ceq -> "i64.eq" | Iunsigned Cne -> "i64.ne" | Iunsigned Cle -> "i64.le_u"
  | Iunsigned Cge -> "i64.ge_u" | Iunsigned Clt -> "i64.lt_u" | Iunsigned Cgt -> "i64.gt_u"

let output_epilogue env f =
  if env.f.fun_frame_required then begin
    let n = (frame_size env) - 8 in
    if n <> 0 then begin
      `	global.get __stack_pointer\n`;
      `	i64.const {emit_int n}\n`;
      `	i64.add\n`;
      `	global.set __stack_pointer\n`;
      cfi_adjust_cfa_offset (-n);
    end;
    f ();
    (* reset CFA back cause function body may continue *)
    if n <> 0 then cfi_adjust_cfa_offset n
  end
  else
    f ()

let emit_named_text_section func_name =
  `	.section .text.caml.{emit_symbol func_name},{emit_string_literal ""},@\n`

let is_magic_function =
  String.starts_with ~prefix:"caml_"

let function_entry env i =
  let lbl = record_frame env i.live (Dbg_other i.dbg) in
  `	global.get	__stack_pointer\n`;
  `	i64.const	8\n`;
  `	i64.sub\n`;
  `	global.set	__stack_pointer\n`;
  `	global.get	__stack_pointer\n`;
  `	i64.const {emit_label lbl}\n`;
  `	i64.store 0\n`

let function_cleanup env i =
  `	global.get	__stack_pointer\n`;
  `	i64.const	8\n`;
  `	i64.add\n`;
  `	global.set	__stack_pointer\n`;
  begin match Array.length i.res with
  | 1 ->
    (fun () -> ()) |>
    emit_set_reg env i.res.(0)
  | 0 ->
    `	drop\n`
  | _ -> assert false end

let emit_direct_call func ~tailcall =
  let emit_call = match tailcall with
  | false -> emit_jump "call"
  | true -> emit_jump "return_call" in
  let func = match is_magic_function func with
    | true -> func
    | false -> func ^ "_raw"
  in
  `	{emit_call func}\n`

let emit_indirect_call i ~tailcall =
  let emit_args args =
    emit_string
      (String.concat ", "
        (List.map (fun r -> get_type r.typ) (Array.to_list args |> List.tl)))
  in
  let call = match tailcall with
  | false -> "call_indirect"
  | true -> "return_call_indirect"
  in
  `	{emit_string call} ({emit_args i.arg}) -> (i64)\n`

let emit_direct_call_args env i =
  for j = 0 to Array.length i.arg - 1 do
    emit_get_reg env i.arg.(j);
  done

let emit_indirect_call_args env i =
  for j = 1 to Array.length i.arg - 1 do
    emit_get_reg env i.arg.(j);
  done;
  emit_get_reg env i.arg.(0);
  `	i32.wrap_i64\n`

type wasm_typ = I32 | I64 | F32 | F64

let emit_wasm_typ = function
  | I32 ->`i32`
  | I64 ->`i64`
  | F32 ->`f32`
  | F64 ->`f64`

let rec emit_wasm_types = function
  | [] -> ()
  | [typ] ->
    emit_wasm_typ typ
  | typ :: tl ->
    emit_wasm_typ typ;
    emit_string ", ";
    emit_wasm_types tl

let ext_func_type_overrides =
  Hashtbl.of_seq (List.to_seq
  [
    "caml_modify", ([I64; I64], []);
    "caml_initialize", ([I64; I64], []);
    "caml_alloc", ([I64; I32], [I64]);
    "caml_tettsttttt", ([I64; I64], [F32]);
    "caml_int32_bits_of_float_unboxed", ([F64], [I32]);
    "caml_int32_to_float_unboxed", ([I32], [F64]);
    "caml_int32_of_float_unboxed", ([F64], [I32]);
    "caml_gc_minor_words_unboxed", ([], [F64]);
  ])

let get_ext_func_type_override func =
  Hashtbl.find_opt ext_func_type_overrides func

let emit_ext_call env i func =
  add_used_symbol func;
  let override = get_ext_func_type_override func in
  begin match override with
  | Some([], _) -> ()
  | Some(args, _) ->
    for j = 0 to Array.length i.arg - 1 do
      emit_get_reg env i.arg.(j);
      match i.arg.(j), List.nth args j with
      | {typ=Int|Val|Addr}, I32 ->
         `	i32.wrap_i64\n`;
      | _ -> ()
    done
  | None ->
      emit_direct_call_args env i
  end;
  `	{emit_call func}\n`;
  match Array.length i.res, override with
  | 1, Some(_, [I32]) ->
     `	i64.extend_i32_s\n`;
    (fun () -> ()) |>
    emit_set_reg env i.res.(0)
  | 1, _ ->
    (fun () -> ()) |>
    emit_set_reg env i.res.(0)
  | 0, Some(_, []) -> ()
  | 0, _ ->
    `	drop\n`;
  | _ -> assert false

let emit_instr env i =
  let emit_get_reg = emit_get_reg env in
  let emit_set_reg = emit_set_reg env in
  let emit_store = emit_store env in
  let _emit_load = emit_load env in
  emit_debug_info i.dbg;
  match i.desc with
  | Wprologue ->
      assert (env.f.fun_prologue_required);
      if env.f.fun_frame_required then begin
        let n = (frame_size env) - 8 in
        if n <> 0 then begin
          `	global.get __stack_pointer\n`;
          `	i64.const {emit_int n}\n`;
          `	i64.sub\n`;
          `	global.set __stack_pointer\n`
        end;
        cfi_adjust_cfa_offset n;
      end
  | Wend ->
      `	unreachable\n`
  | Wloop lbl ->
      push_lbl lbl;
      `	loop\n`
  | Wblock lbl ->
      push_lbl lbl;
      `#{emit_label lbl}:\n`;
      `	block\n`
  | Wendloop ->
      pop_lbl ();
      `	end_loop\n`
  | Wendblock ->
      `#end-{emit_label (List.hd !lbl_stack)}\n`;
      pop_lbl ();
      `	end_block\n`
  | Wtry ->
      push_lbl (new_label ());
      `	global.get __stack_pointer\n`;
      `	i64.const 16\n`;
      `	i64.sub\n`;
      `	global.set __stack_pointer\n`;
      `	global.get __stack_pointer\n`;
      get_domain_field Domainstate.Domain_exception_pointer;
      `	i64.store 0\n`;
      (fun () ->
      `	global.get __stack_pointer\n`;
      ) |>
      set_domain_field Domainstate.Domain_exception_pointer;
      env.stack_offset <- env.stack_offset + 16;
      `	try\n`
  | Wcatch handler_lbl ->
      pop_lbl ();
      `	catch __ocaml_exception\n`;
      (fun () -> ()) |>
      emit_set_reg (phys_reg 0);
      let branch_idx = 1 + get_idx handler_lbl in
      `	br	{emit_int branch_idx}\n`;
      `	end_try\n`
  | Wpoptrap ->
      env.stack_offset <- env.stack_offset - 16;
      (fun () ->
      `	global.get __stack_pointer\n`;
      `	i64.load 0\n`;
      ) |>
      set_domain_field Domainstate.Domain_exception_pointer;
      `	global.get __stack_pointer\n`;
      `	i64.const 16\n`;
      `	i64.add\n`;
      `	global.set __stack_pointer\n`;
  | Wadjust_trap_depth delta_traps ->
      (* each trap occupies 16 bytes on the stack *)
      assert (delta_traps = 1 || delta_traps = -1);
      let delta = 16 * delta_traps in
      env.stack_offset <- env.stack_offset + delta
  | Wswitch jumptbl ->
      emit_get_reg i.arg.(0);
      `	i32.wrap_i64\n`;
      `	br_table \{{emit_string (String.concat ", " (Array.to_list (Array.map (fun lbl -> Int.to_string (get_idx lbl)) jumptbl)))}}\n`
  | Wbranch lbl ->
      `#br {emit_label lbl}\n`;
      let branch_idx = get_idx lbl in
      `	br	{emit_int branch_idx}\n`
  | Wtailrec lbl ->
      assert ((Array.length i.arg) = (Array.length env.f.fun_args));
      `#br {emit_label lbl}\n`;
      Array.iter emit_get_reg i.arg;
      for i = Array.length env.f.fun_args - 1 downto 0 do
        (fun () -> ()) |> emit_set_reg (env.f.fun_args.(i));
      done;
      let branch_idx = get_idx lbl in
      `	br	{emit_int branch_idx}\n`
  | Wcondbranch(tst, lbl) ->
      `#condbr {emit_label lbl}\n`;
      let branch_idx = get_idx lbl in
        begin match tst with
        | Itruetest ->
            emit_get_reg i.arg.(0);
            `	i64.eqz\n`;
            `	i32.eqz\n`;
            `	br_if	{emit_int branch_idx}\n`
        | Ifalsetest ->
            emit_get_reg i.arg.(0);
            `	i64.eqz\n`;
            `	br_if	{emit_int branch_idx}\n`
        | Iinttest cmp ->
            let comp = name_for_comparison cmp in
            emit_get_reg i.arg.(0);
            emit_get_reg i.arg.(1);
            `	{emit_string comp}\n`;
            `	br_if	{emit_int branch_idx}\n`
        | Iinttest_imm(cmp, n) ->
            let comp = name_for_comparison cmp in
            emit_get_reg i.arg.(0);
            `	i64.const	{emit_int n}\n`;
            `	{emit_string comp}\n`;
            `	br_if	{emit_int branch_idx}\n`
        | Ifloattest cmp ->
            emit_get_reg i.arg.(0);
            emit_get_reg i.arg.(1);
            begin match cmp with
            | CFeq ->
                `	f64.eq\n`
            | CFneq ->
                `	f64.ne\n`
            | CFlt ->
                `	f64.lt\n`
            | CFnlt ->
                `	f64.lt\n`;
                `	i32.eqz\n`
            | CFle ->
                `	f64.le\n`;
            | CFnle ->
                `	f64.le\n`;
                `	i32.eqz\n`
            | CFgt ->
                `	f64.gt\n`
            | CFngt ->
                `	f64.gt\n`;
                `	i32.eqz\n`
            | CFge ->
                `	f64.ge\n`
            | CFnge ->
                `	f64.ge\n`;
                `	i32.eqz\n`
            end;
            `	br_if	{emit_int branch_idx}\n`
        | Ioddtest ->
            emit_get_reg i.arg.(0);
            `	i64.const 1\n`;
            `	i64.and\n`;
            `	i64.const 0\n`;
            `	i64.ne\n`;
            `	br_if	{emit_int branch_idx}\n`
        | Ieventest ->
            emit_get_reg i.arg.(0);
            `	i64.const 1\n`;
            `	i64.and\n`;
            `	i64.eqz\n`;
            `	br_if	{emit_int branch_idx}\n`
        end
  | Wunreachable ->
      `	unreachable\n`
  | Wreturn ->
      output_epilogue env begin fun () ->
        for j = 0 to Array.length i.arg - 1 do
          emit_get_reg i.arg.(j);
        done;
        `	return\n`
      end
  | Wop(Iconst_int n) ->
      (fun () -> `	i64.const {emit_nativeint n}\n`) |>
      emit_set_reg i.res.(0);
  | Wop(Ipoll { return_label } ) ->
       (* CR: safepoints :( *)
       ()
  | Wop(Ialloc { bytes = n; dbginfo }) ->
      `	global.get    __caml_young_ptr\n`;
      `	i64.const {emit_int n}\n`;
      `	i64.sub\n`;
      `	global.set    __caml_young_ptr\n`;
      let lbl = new_label () in
      (* let lbl = record_frame_label env i.live (Dbg_alloc dbginfo) in *)
      fake_address_labels := lbl :: !fake_address_labels;
      `{emit_label lbl}_fake:\n`;
      `	block\n`;
      `	global.get    __caml_young_ptr\n`;
      get_domain_field Domainstate.Domain_young_limit;
      `	i64.ge_u\n`;
      `	br_if 0\n`;
      let num_live_ptrs = Reg.Set.fold (fun reg acc ->
        match reg with
        | {typ = Val} -> acc + 1
        | _ -> acc) i.live 0 in
      let aligned_stack_val = ((8 * num_live_ptrs-1) land (lnot(16-1))) + 16 in
      `	i64.const {emit_label lbl}\n`;
      `	global.get __stack_pointer\n`;
      `	global.get __stack_pointer\n`;
      `	i64.const {emit_int aligned_stack_val}\n`;
      `	i64.sub\n`;
      `	global.set __stack_pointer\n`;
      let live_offset = ref [] in
      let j = ref 0 in
      Reg.Set.iter
        (function
          | {typ = Val; loc = Reg _ } as reg ->
              `	global.get __stack_pointer\n`;
              emit_get_reg reg;
              `	i64.store {emit_int (!j * size_addr)}\n`;
              live_offset := ((!j lsl 1) + 1) :: !live_offset;
              incr j
          | {typ = Val; loc = Stack s} as reg ->
             live_offset := slot_offset env s (register_class reg) :: !live_offset
          | {typ = Addr} as r ->
              Misc.fatal_error ("bad GC root " ^ Reg.name r)
          | _ -> ())
        i.live;
      record_frame_descr ~label:lbl ~frame_size:(frame_size env)
        ~live_offset:!live_offset (Dbg_alloc dbginfo);
      `	call caml_call_gc\n`;
      j := 0;
      Reg.Set.iter
        (function
          | {typ = Val; loc = Reg _ } as reg ->
              (fun () ->
              `	global.get __stack_pointer\n`;
              `	i64.load {emit_int (!j * size_addr)}\n`) |>
              emit_set_reg reg;
              incr j
          | {typ = Addr} as r ->
              Misc.fatal_error ("bad GC root " ^ Reg.name r)
          | _ -> ())
        i.live;
      `	global.get __stack_pointer\n`;
      `	i64.const {emit_int aligned_stack_val}\n`;
      `	i64.add\n`;
      `	global.set __stack_pointer\n`;
      `	end_block\n`;
      (fun () ->
      `	global.get    __caml_young_ptr\n`;
      `	i64.const {emit_int size_addr}\n`;
      `	i64.add\n`;
      emit_conversion Addr i.res.(0).typ) |>
      emit_set_reg i.res.(0)
  | Wop(Icall_imm {func}) ->
      add_used_symbol func;
      emit_direct_call_args env i;
      function_entry env i;
      emit_direct_call func ~tailcall:false;
      function_cleanup env i
  | Wop(Icall_ind) ->
      emit_indirect_call_args env i;
      function_entry env i;
      emit_indirect_call i ~tailcall:false;
      function_cleanup env i
  | Wop(Itailcall_imm { func; }) ->
      add_used_symbol func;
      emit_direct_call_args env i;
      output_epilogue env begin fun () ->
        emit_direct_call func ~tailcall:true;
      end
  | Wop(Itailcall_ind) ->
      emit_indirect_call_args env i;
      output_epilogue env begin fun () ->
        emit_indirect_call i ~tailcall:true;
      end
  | Wop(Iextcall{func; alloc = true}) ->
      let lbl = record_frame env i.live (Dbg_other i.dbg) in
      `	i64.const {emit_label lbl}\n`;
      `	global.get __stack_pointer\n`;
      `	{emit_call "caml_before_c_call"}\n`;
      emit_ext_call env i func;
      `	{emit_call "caml_after_c_call"}\n`
  | Wop(Iextcall{func; alloc = false}) ->
      emit_ext_call env i func
  | Wop(Iconst_symbol s) ->
      if String.starts_with ~prefix:"caml_c" s || String.starts_with ~prefix:"caml_t" s then
        `	.type	{emit_symbol s}, @function\n`;
      (fun () -> `	i64.const	{emit_symbol s}\n`) |>
      emit_set_reg i.res.(0)
  | Wop(Iload(chunk, Iindexed ofs, _mut)) ->
      let dst = i.res.(0) in
      let src = i.arg.(0) in
      emit_get_reg src;
      `	i64.const    {emit_int ofs}\n`;
      `	i64.add\n`;
      let instr =
        match chunk with
        | Word_int ->
            "i64.load"
        | Word_val ->
            "i64.load"
        | Byte_unsigned ->
            "i64.load8_u"
        | Byte_signed ->
            "i64.load8_s"
        | Sixteen_unsigned ->
            "i64.load16_u"
        | Sixteen_signed ->
            assert false
        | Thirtytwo_unsigned ->
            "i64.load32_u"
        | Thirtytwo_signed ->
            "i64.load32_s"
        | Single ->
            assert false
        | Double ->
            "f64.load"
      in
      `	{emit_string instr} 0\n`;
      emit_set_reg dst (fun _ -> ())
  | Wop(Istore(size, Iindexed ofs, _)) ->
      let src = i.arg.(0) in
      let dst = i.arg.(1) in
      begin match size with
      | Byte_unsigned | Byte_signed ->
          emit_get_reg dst;
          `	i64.const    {emit_int ofs}\n`;
          `	i64.add\n`;
          emit_get_reg src;
          `	i64.store8    0\n`
      | Sixteen_unsigned | Sixteen_signed ->
          emit_get_reg dst;
          `	i64.const    {emit_int ofs}\n`;
          `	i64.add\n`;
          emit_get_reg src;
          `	i64.store16    0\n`
      | Thirtytwo_unsigned | Thirtytwo_signed ->
          emit_get_reg dst;
          `	i64.const    {emit_int ofs}\n`;
          `	i64.add\n`;
          emit_get_reg src;
          `	i64.store32    0\n`
      | Single ->
          assert false
      | Word_int ->
          emit_store src dst ~ofs
      | Double ->
          emit_get_reg dst;
          `	i64.const    {emit_int ofs}\n`;
          `	i64.add\n`;
          emit_get_reg src;
          `	f64.store    0\n`
      | Word_val ->
          emit_store src dst ~ofs
      end
  | Wop(Iintop (Icomp cmp)) ->
      let comp = name_for_comparison cmp in
      (fun () ->
      emit_get_reg i.arg.(0);
      emit_get_reg i.arg.(1);
      `	{emit_string comp}\n`;
      `	i64.extend_i32_u\n`;
      ) |>
      emit_set_reg i.res.(0)
  | Wop(Iintop_imm (Icomp cmp, n)) ->
      let comp = name_for_comparison cmp in
      (fun () ->
      emit_get_reg i.arg.(0);
      `	i64.const	{emit_int n}\n`;
      `	{emit_string comp}\n`;
      `	i64.extend_i32_u\n`;
      ) |>
      emit_set_reg i.res.(0)
  | Wop(Iintop (Icheckbound)) ->
    emit_get_reg i.arg.(1);
    emit_get_reg i.arg.(0);
    `	i64.ge_u\n`;
    `	if\n`;
    let lbl = record_frame env Reg.Set.empty (Dbg_other i.dbg) in
    `	i64.const {emit_label lbl}\n`;
    `	{emit_call "caml_ml_array_bound_error"}\n`;
    `	end_if\n`;
  | Wop(Iintop_imm(Icheckbound, n)) ->
    `	i64.const    {emit_int n}\n`;
    emit_get_reg i.arg.(0);
    `	i64.ge_u\n`;
    `	if\n`;
    let lbl = record_frame env Reg.Set.empty (Dbg_other i.dbg) in
    `	i64.const {emit_label lbl}\n`;
    `	{emit_call "caml_ml_array_bound_error"}\n`;
    `	end_if\n`;
  | Wop(Iintop op) ->
      let instr = name_for_int_operation op in
      assert (get_type (i.arg.(0).typ) = get_type (i.arg.(1).typ));
      (fun () ->
      emit_get_reg i.arg.(0);
      emit_get_reg i.arg.(1);
      `	i64.{emit_string instr}\n`;
      emit_conversion i.arg.(0).typ i.res.(0).typ) |>
      emit_set_reg i.res.(0)
  | Wop(Imove | Ispill | Ireload) ->
      let src = i.arg.(0) and dst = i.res.(0) in
      if src.loc <> dst.loc then begin
        match src.typ, dst.typ with
        | (Val | Addr), Int ->
            (fun () ->
            emit_get_reg src) |>
            emit_set_reg dst;
        | Addr, Val
        | Val, Addr
        | Val, Val
        | Addr, Addr
        | Int, Int
        | Float, Float ->
            (fun () -> emit_get_reg src) |>
            emit_set_reg dst;
        | Int, (Val | Addr) ->
            (fun () ->
            emit_get_reg src) |>
            emit_set_reg dst;
        | Float, _ ->
            assert false
        | _, Float ->
            assert false
      end
  | Wop(Iopaque) ->
      assert (i.arg.(0).loc = i.res.(0).loc)
  | Wop(Istackoffset _) -> assert false
  | Wop(Iintop_imm (op, n)) ->
      let instr = name_for_int_operation op in
      (fun () ->
      emit_get_reg i.arg.(0);
      `	i64.const {emit_int n}\n`;
      `	i64.{emit_string instr}\n`;
      emit_conversion i.arg.(0).typ i.res.(0).typ) |>
      emit_set_reg i.res.(0)
  | Wop(Ispecific _) -> assert false
  | Wop(Iabsf | Inegf | Ifloatofint as op) ->
      let instr = match op with
      | Iabsf -> "abs"
      | Inegf -> "neg"
      | Ifloatofint -> "convert_i64_s"
      | _     -> assert false
      in
      (fun () ->
      emit_get_reg i.arg.(0);
      `	f64.{emit_string instr}\n`;
      ) |>
      emit_set_reg i.res.(0)
  | Wop(Iaddf | Isubf | Imulf | Idivf as op) ->
      let instr = match op with
      | Iaddf -> "add"
      | Isubf -> "sub"
      | Imulf -> "mul"
      | Idivf -> "div"
      | _     -> assert false
      in
      (fun () ->
      emit_get_reg i.arg.(0);
      emit_get_reg i.arg.(1);
      `	f64.{emit_string instr}\n`;
      ) |>
      emit_set_reg i.res.(0)
  | Wop(Iintoffloat) ->
      (fun () ->
      emit_get_reg i.arg.(0);
      `	i64.trunc_f64_s\n`;
      ) |>
      emit_set_reg i.res.(0)
  | Wop(Iconst_float f) ->
      (fun () ->
      let float = Int64.float_of_bits f in
      let f_str = Printf.sprintf "%h" float in
      `	f64.const { emit_string f_str }\n`;
      ) |>
      emit_set_reg i.res.(0);
  | Wraise k ->
      assert (Array.length i.arg = 1);
      begin match k with
      | Lambda.Raise_regular ->
          (fun () ->
          `	i64.const 0\n`;
          ) |>
          set_domain_field Domainstate.Domain_backtrace_pos;
          let lbl = record_frame_label env Reg.Set.empty (Dbg_raise i.dbg) in
          fake_address_labels := lbl :: !fake_address_labels;
          `{emit_label lbl}_fake:\n`;
          emit_get_reg i.arg.(0);
          `	i64.const {emit_label lbl}\n`;
          `	{emit_call "caml_raise_exn"}\n`;
          `	unreachable\n`;
      | Lambda.Raise_reraise ->
          let lbl = record_frame_label env Reg.Set.empty (Dbg_raise i.dbg) in
          fake_address_labels := lbl :: !fake_address_labels;
          `{emit_label lbl}_fake:\n`;
          emit_get_reg i.arg.(0);
          `	i64.const {emit_label lbl}\n`;
          `	{emit_call "caml_raise_exn"}\n`;
          `	unreachable\n`;
      | Lambda.Raise_notrace ->
          get_domain_field Domainstate.Domain_exception_pointer;
          `	global.set __stack_pointer\n`;
          (fun () ->
          `	global.get __stack_pointer\n`;
          `	i64.load 0\n`;
          ) |>
          set_domain_field Domainstate.Domain_exception_pointer;
          `	global.get __stack_pointer\n`;
          `	i64.const 16\n`;
          `	i64.add\n`;
          `	global.set __stack_pointer\n`;
          emit_get_reg i.arg.(0);
          `	throw __ocaml_exception\n`;
          `	drop\n`;
          `	unreachable\n`;
      end
  | Wcondbranch3 (_, _, _) -> assert false

let emit_args args =
  emit_string (String.concat ", " (List.map (fun r -> get_type r.typ) (Array.to_list args)))

(* let rec emit_all env = function *)
(*   | {desc = Lend} -> () | i -> emit_instr env i; emit_all env i.next *)

let emit_all env fundecl =
  let instrs = match true with | true -> cfg_reloop fundecl | false -> reloop fundecl.fun_body in
  List.iter (emit_instr env) instrs

module RegOrder =
  struct
    type t = Reg.t
    let compare r1 r2 =
      match r1.typ, r2.typ with
      | Addr, Addr
      | Int, Int
      | Val, Val
      | Float, Float
      | Addr, Val
      | Val, Addr ->
          (match r1.loc, r2.loc with
          | Reg r1, Reg r2 -> Int.compare r1 r2
          | _ -> assert false)
      | (Val | Addr), (Int | Float) -> 1
      | (Int | Float), (Val | Addr) -> -1
      | Int , Float -> 1
      | Float, Int -> -1
  end
module RegSet = Stdlib.Set.Make(RegOrder)

let rec get_regs set = function
  | Linear.{ desc = Lend } -> set
  | instr ->
      let add_arr = Array.fold_left (fun set -> function {loc = Reg _ } as reg -> RegSet.add reg set | _ -> set) in
      let set = add_arr set instr.Linear.arg in
      let set = add_arr set instr.Linear.res in
      get_regs set instr.next

let emit_locals fundecl =
  let compare_reg r1 r2 =
    match r1.typ, r2.typ with
    | Addr, Addr
    | Int, Int
    | Val, Val
    | Float, Float
    | Addr, Val
    | Val, Addr ->
        (match r1.loc, r2.loc with
        | Reg r1, Reg r2 -> Int.compare r1 r2
        | _ -> assert false)
    | (Val | Addr), (Int | Float) -> 1
    | (Int | Float), (Val | Addr) -> -1
    | Int , Float -> 1
    | Float, Int -> -1
  in
  let regs =
    get_regs RegSet.empty fundecl.fun_body
    |> (fun s -> RegSet.diff s (RegSet.of_list (Array.to_list fundecl.fun_args)))
    |> RegSet.to_seq
    |> List.of_seq
    |> List.filter (function { loc = Reg _ } -> true | _ -> false)
    |> List.sort_uniq compare_reg
  in
  let regs = regs @ [loop_idx_reg] in
  let regs_with_args = (Array.to_list fundecl.fun_args) @ regs in
  Hashtbl.clear reg_map;
  List.iteri (fun i reg -> Hashtbl.add reg_map reg.loc i) regs_with_args;
  let types = List.map (fun reg -> get_type reg.typ) regs in
  `	.local {emit_string (String.concat ", " types)}\n`

let emit_called_funcs fundecl =
  let rec emit_funcs = function
  | Linear.{ desc = Lend } -> ()
  | Linear.{ desc = Lop(Icall_imm {func} | Itailcall_imm {func}) } as i ->
      let func = match is_magic_function func with
        | true -> func
        | false -> func ^ "_raw"
      in
      if not (String.Set.mem func !symbols_defined) then
        `	.functype {emit_symbol func} ({emit_args i.arg}) -> (i64)\n`;
      emit_funcs i.next
  | Linear.({ desc = Lop(Iextcall { func }) } as i) ->
      begin match get_ext_func_type_override func with
      | Some (args, res) ->
        `	.functype {emit_symbol func} ({emit_wasm_types args}) -> ({emit_wasm_types res})\n`;
        emit_funcs i.next
      | None ->
        let dst_typ = match Array.to_list i.res with
        | [] -> "i64"
        | [ {typ = Float} ] -> "f64"
        | [ _ ] -> "i64"
        | _ -> assert false in
        `	.functype {emit_symbol func} ({emit_args i.arg}) -> ({emit_string dst_typ})\n`;
        emit_funcs i.next
      end
  | i -> emit_funcs i.next
  in
  emit_funcs fundecl.fun_body

let fundecl fundecl =
  let env = mk_env fundecl in
  fake_address_labels := [];
  emit_named_text_section fundecl.fun_name;
  let { fun_name; _ } = fundecl in
  (* Printf.printf "%s\n" fun_name; *)
  let fun_name = match is_magic_function fun_name with
    | true -> fun_name
    | false -> fun_name ^ "_raw"
  in
  add_def_symbol fun_name;
  `	.globl	{emit_symbol fun_name}\n`;
  `	.type	{emit_symbol fun_name}, @function\n`;
  `{emit_symbol fun_name}:\n`;
  emit_called_funcs fundecl;
  `	.functype {emit_symbol fun_name} ({emit_args fundecl.fun_args}) -> (i64)\n`;
  emit_locals fundecl;
  emit_debug_info fundecl.fun_dbg;
  cfi_startproc();
  emit_all env fundecl;
  `	end_function\n`;
  (* List.iter emit_call_gc env.call_gc_sites; *)
  (* List.iter emit_call_bound_error env.bound_error_sites; *)
  if fundecl.fun_frame_required then begin
    let n = (frame_size env) - 8  in
    if n <> 0 then begin
      cfi_adjust_cfa_offset (-n);
    end;
  end;
  cfi_endproc();
  if is_magic_function fundecl.fun_name |> not then begin
    (* Wrapper *)
    emit_named_text_section fundecl.fun_name;
    add_def_symbol fundecl.fun_name;
    `	.globl	{emit_symbol (fundecl.fun_name)}\n`;
    `	.type	{emit_symbol fundecl.fun_name}, @function\n`;
    `{emit_symbol fundecl.fun_name}:\n`;
    let args = String.concat ", " ((List.map (fun r -> get_type r.typ) (Array.to_list fundecl.fun_args)) @ (if fundecl.fun_uses_env then [] else ["i64"])) in
    `	.functype {emit_symbol fundecl.fun_name} ({emit_string args}) -> (i64)\n`;
      for j = 0 to Array.length fundecl.fun_args - 1 do
        `	local.get {emit_int j}\n`;
      done;
      `	return_call {emit_symbol fun_name}\n`;
      `	end_function\n`;
  end;
  if !fake_address_labels <> [] then begin
    (* Cannot be made rodata as otherwise this will be optimised away *)
    `	{emit_string data_space}\n`;
    List.iter
      (fun lbl ->
        `{emit_label lbl}:\n`;
        `	.byte	{emit_int 0}\n`;
        `	.size	{emit_label lbl}, 1\n`
      )
      !fake_address_labels;
  end;
  (* Emit the float literals *)
  if env.float_literals <> [] then begin
    `	{emit_string rodata_space}\n`;
    `	.align	3\n`;
    List.iter
      (fun {fl; lbl} ->
        `{emit_label lbl}:\n`;
        emit_float64_directive ".quad" fl)
      env.float_literals;
  end

let declare_global_data s =
  `	.globl	{emit_symbol s}\n`;
  `	.type	{emit_symbol s}, @object\n`

let current_symbol = ref ""

let set_current_symbol s =
  if not (s = !current_symbol) then
    if not (!current_symbol = "") then
      `	.size	{emit_symbol !current_symbol}, .-{emit_symbol !current_symbol}\n`;
    current_symbol := s

let emit_item is_closure = function
  | Cglobal_symbol s ->
      set_current_symbol s;
      declare_global_data s
  | Cdefine_symbol s ->
      set_current_symbol s;
      add_def_symbol s;
      `{emit_symbol s}:\n`
  | Cint8 n ->
      `	.byte	{emit_int n}\n`
  | Cint16 n ->
      `	.short	{emit_int n}\n`
  | Cint32 n ->
      `	.long	{emit_nativeint n}\n`
  | Cint n ->
      `	.quad	{emit_nativeint n}\n`
  | Csingle f ->
      emit_float32_directive ".long" (Int32.bits_of_float f)
  | Cdouble f ->
      emit_float64_directive ".quad" (Int64.bits_of_float f)
  | Csymbol_address s ->
      if is_closure then
          `	.type	{emit_symbol s}, @function\n`;
      `	.quad	{emit_symbol s}\n`
  | Cstring s ->
      emit_string_directive "	.ascii  " s
  | Cskip n ->
      if n > 0 then `	.space	{emit_int n}\n`
  | Calign n ->
      `	.align	{emit_int (Misc.log2 n)}\n`

(* Emission of data *)
let data l =
  let is_closure =
    match l  with
    | Cint n :: _ when ((Nativeint.to_int n) land 0xFF) == 0xF7 -> true
    | Csymbol_address _ :: _ -> true
    | _ -> false
  in
  match l with
  | [] -> ()
  | _ ->
  `	{emit_string data_space}\n`;
  `	.align 8\n`;
  List.iter (emit_item is_closure) l;
  set_current_symbol ""

(* Beginning / end of an assembly file *)

let emit_symbol_size sym =
    `	.size	{emit_symbol sym}, .-{emit_symbol sym}\n`
let emit_symbol_type emit_lbl_or_sym lbl_or_sym ty =
    `	.type	{emit_lbl_or_sym lbl_or_sym}, @{emit_string ty}\n`
let begin_assembly() =
  `	.file \"\"\n`;
  reset_debug_info();
  let lbl_begin = Compilenv.make_symbol (Some "data_begin") in
  `	{emit_string data_space}\n`;
  declare_global_data lbl_begin;
  `{emit_symbol lbl_begin}:\n`;
  emit_symbol_size lbl_begin;
  let lbl_begin = Compilenv.make_symbol (Some "code_begin") in
  declare_global_data lbl_begin;
  `{emit_symbol lbl_begin}:\n`;
  emit_symbol_size lbl_begin;
  `	.tagtype	__ocaml_exception i64\n`;
  `	.globaltype	__caml_young_ptr, i64\n`;
  `	.globaltype	__caml_state, i64\n`;
  `	.globaltype	__stack_pointer, i64\n`;
  `	.functype	caml_before_c_call (i64, i64) -> ()\n`;
  `	.functype	caml_after_c_call () -> ()\n`;
  `	.functype	caml_call_gc (i64, i64) -> ()\n`;
  `	.functype	caml_raise_exn (i64, i64) -> ()\n`;
  `	.functype	caml_ml_array_bound_error (i64) -> ()\n`;
  ()

let end_assembly() =
  let lbl_end = Compilenv.make_symbol (Some "code_end") in
  emit_named_text_section lbl_end;
  `	{emit_string data_space}\n`;
  `	.globl	{emit_symbol lbl_end}\n`;
  `{emit_symbol lbl_end}:\n`;
  emit_symbol_size lbl_end;
  `	.quad	0\n`;  (* PR#6329 *)
  let lbl_end = Compilenv.make_symbol (Some "data_end") in
  `	.globl	{emit_symbol lbl_end}\n`;
  `{emit_symbol lbl_end}:\n`;
  emit_symbol_size lbl_end;
  `	.quad	0\n`;
  `	.align	3\n`;  (* #7887 *)
  let lbl = Compilenv.make_symbol (Some "frametable") in
  `	.globl	{emit_symbol lbl}\n`;
  `{emit_symbol lbl}:\n`;
  emit_frames
  (* CR: return addresses are used to identify which frame we are in, as such we need to come up with
     a way of generating globally unique addresses, we also need to add these to the stack when we
     function call as these form a linked list which is used by the gc. *)
    { efa_code_label = (fun lbl -> `	.quad	{emit_label lbl}\n`);
      efa_data_label = (fun lbl ->
                       emit_symbol_type emit_label lbl "object";
                       `	.quad	{emit_label lbl}\n`);
      efa_8 = (fun n -> `	.byte	{emit_int n}\n`);
      efa_16 = (fun n -> `	.short	{emit_int n}\n`);
      efa_32 = (fun n -> `	.long	{emit_int32 n}\n`);
      efa_word = (fun n -> `	.quad	{emit_int n}\n`);
      efa_align = (fun n -> `	.align	{emit_int(Misc.log2 n)}\n`);
      efa_label_rel = (fun lbl ofs ->
                           `	.long	{emit_label lbl} - . + {emit_int32 ofs}\n`);
      efa_def_label = (fun lbl -> `{emit_label lbl}:\n`);
      efa_string = (fun s -> emit_string_directive "	.asciz	" s) };
  emit_symbol_type emit_symbol lbl "object";
  emit_symbol_size lbl;
  (* String.Set.iter *)
  (*   (fun s -> *)
  (*      if not (String.Set.mem s !symbols_defined) then *)
  (*        `	.functype { emit_symbol s } () -> ()`) *)
  (*   !symbols_used; *)
  symbols_used := String.Set.empty;
  symbols_defined := String.Set.empty;

